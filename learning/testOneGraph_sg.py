import torch
import os
import dgl
from Dataloader import dataload
from torch.utils.data import SequentialSampler
from dgl.dataloading import GraphDataLoader
import pandas as pd
import re
from itertools import islice
weakness_name = ['block number dependency', 'dangerous delegatecall', 'ether frozen', 'ether strict equality',
                 'integer overflow', 'reentrancy', 'timestamp dependency', 'unchecked external call']

saved_model_path = os.path.abspath('../sku3343/dataset/model/')
models=[]
for weakness in weakness_name:
    model1 = torch.load(saved_model_path+'/'+weakness)
    model1.eval()
    models.append(model1)
    
    
#model.eval()  # 모델을 평가 모드로 설정

# 데이터셋 불러오기
dataset_path = os.path.abspath('../sku3343/dataset/dgl_graph')
ds=weakness_name[0]
dataset = dataload(ds, dataset_path)

dataset_len = len(dataset)
print(dataset_len)
sampler = SequentialSampler(torch.arange(dataset_len))
dataloader = GraphDataLoader(dataset, sampler=sampler, batch_size=1, drop_last=False)

result_data=[]
pr_value=[]
c_tk=0
c_pass=0
c_fn=0
c_tn=0
c_fp=0
cnt=0
for batched_graph, labels, n in dataloader:
    p_m=[]
    prs=[]
    topk={}
    cnt=cnt+1
    try:
        for md in models:
    # 예측 수행
            pred = md(batched_graph)

            print("\nPredictions:", pred)
            print("Actual Labels:", labels)
            print()
    
            l=labels.detach().tolist()
    #예측 수치
    # print("모델의 예측 수치:", pred)
    
    # #예측 결과 확인을 위한 출력
            print("예측 값:", torch.argmax(pred).item())
            pr_before=[round(item, 4) for item in pred.tolist()[0]]
        
            pr_after=[]
            threshold=0.7
            if pr_before[1]<threshold:
                p_m.append((pr_before,0))
                prs.append(0)
            else:
                p_m.append((pr_before,1))
                prs.append(pr_before[1])
        m=prs.index(max(prs))
        for i in range(0,8):
            topk[weakness_name[i]]=p_m[i][0][1]
        topk=sorted(topk.items(), key=lambda x:x[1], reverse=True)
        top_three = dict(topk[:4])
        rs=''
    
        if (ds in top_three) & labels.tolist()[0]==1:
            rs='right'
            c_tk=c_tk+1
        elif (ds not in top_three) &labels.tolist()[0]==0:
            c_tn=c_tn+1
        elif (ds not in top_three) & labels.tolist()[0]==1:
            c_fn=c_fn+1
        elif(ds in top_three) & labels.tolist()[0]==0:
            c_fp=c_fp+1
        else:
            rs='wrong'
        result_data.append({'Actual Labels':labels.tolist()[0],'Contract Name':n[0],'top-k':top_three, ds+" is in top 3?" : rs,
                            'block number dependency':p_m[0], 'dangerous delegatecall':p_m[1], 'ether frozen':p_m[2], 'ether strict equality':p_m[3],
                     'integer overflow':p_m[4], 'reentrancy':p_m[5], 'timestamp dependency':p_m[6], 'unchecked external call':p_m[7]})
    except KeyError as e:
        c_pass=c_pass+1

precision = c_tk/(c_tk+c_fp)
recall = c_tk/(c_tk+c_fn)
f1_score=2*precision*recall/(precision+recall)
accuracy=(c_tk+c_tn)/cnt
print("precision : ",precision,"recall : ", recall, "F1-score : ", f1_score, "Accuracy : ",accuracy)
df_result=pd.DataFrame(result_data)
output_excel_path=os.path.abspath('../sku3343/dataset copy/viz_code/'+ds+'_topk4.csv')
df_result.to_csv(output_excel_path, index=False)
print("pass : ",c_pass)
